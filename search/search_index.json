{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenAerialMap","text":"<p>Welcome to the docs!</p> <p>Click on a sidebar link to get started.</p>"},{"location":"about/about/","title":"What is OpenAerialMap?","text":""},{"location":"about/faq/","title":"FAQ","text":""},{"location":"about/timeline/","title":"Timeline","text":"<p>In reverse chronological order, with most recent events first.</p> <p> 2025-05 STAC based OpenAerialMap         \ud83d\ude80 Complete overhaul of the OAM backend, in partnership with          DevelopmentSeed.          2025-01 Drone-TM Release         \ud83d\ude81 A platform to collaboratively collect drone imagery,         but it needs to go somewhere!          2015-11 First Version         \ud83c\udfc1 First version of OAM released.          2014-06 Initial Research &amp; Concept         \ud83d\udd2c OpenAerialMap &amp; Open Imagery Network concept started.         More info here 2007 First Imagery Becomes Available         \ud83d\udef0\ufe0f Some satellite imagery providers started making their data freely         available for disaster response mapping."},{"location":"decisions/","title":"Architectural Decisions","text":"<p>Markdown Architectural Decision Records documenting the technical decisions taken in this project.</p> <p>This process was started 15/08/2025, so does not necessarily capture all decisions from the projects inception.</p>"},{"location":"decisions/#decisions","title":"Decisions","text":"<ul> <li>0000 - HOTOSM Context and Alignment</li> <li>0001 - STAC to catalogue all imagery assets</li> </ul>"},{"location":"decisions/0000-hotosm/","title":"Higher Level HOTOSM Decisions","text":"<p>Many decisions have been made at an organizational level, affecting all tools that we develop.</p> <p>The decisions made in this project should not deviate much from the choices, starting here.</p>"},{"location":"decisions/0001-stac/","title":"Use a STAC to catalogue all imagery assets","text":""},{"location":"decisions/0001-stac/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>We need a way to:</p> <ul> <li>Store metadata about all the imagery in OpenAerialMap.</li> <li>Query the metadata, ideally using filters.</li> <li>Use an API for discoverability of assets, allowing various   downstream components to load in imagery easily.</li> </ul> <p>Historically OpenAerialMap used a MongoDB metadata database to store imagery info.</p> <p>While this worked, it was a custom schema and API that required ongoing maintenance, and it was difficult for external tools to consume without writing bespoke integrations.</p> <p>The STAC Spec (Spatio-Temporal Asset Catalogue) is now a well established, community-driven approach to cataloguing various geospatial assets.</p> <p>There are numerous tools built around STAC, from pre-built web UIs, Python modules to discover and read imagery, etc.</p>"},{"location":"decisions/0001-stac/#considered-options","title":"Considered Options","text":"<p>I think we only really considered STAC, as it's the primary standard built for geospatial metadata cataloguing.</p>"},{"location":"decisions/0001-stac/#decision-outcome","title":"Decision Outcome","text":"<p>We chose STAC as the only sane option in 2025!</p>"},{"location":"decisions/0001-stac/#consequences","title":"Consequences","text":"<ul> <li>\u2705 Interoperability: Many existing clients and libraries can query and parse STAC,   removing the need for us to maintain bespoke things.</li> <li>\u2705 Discoverability: STAC API implementations (e.g., PySTAC, stac-fastapi) allow   easy filtering by time, location, and metadata attributes.</li> <li>\u2705 Future-proofing: The STAC community continues to evolve the spec, adding   extensions for new metadata needs (e.g., processing levels, cloud storage   locations). Should also reduce maintenance burden as a result.</li> <li>\u274c Not many downsides. Possible learning curve with STAC, but lots of resources   available online. It's also bit more complex than our simple metadata schema   previously.</li> </ul>"},{"location":"dev/backup-prod-pgstac/","title":"Backing Up pgSTAC Manually","text":"<ul> <li>pgSTAC is backed up by the PGO Operator on a schedule.</li> <li>However, it might be useful to dump the pgSTAC database locally,   for testing and development purposes.</li> </ul>"},{"location":"dev/backup-prod-pgstac/#dump","title":"Dump","text":"<pre><code># Connect to cluster\nCURRENT_USER=$(whoami)\ndocker run --rm -it --name aws-cli -v /home/$CURRENT_USER:/root \\\n    --workdir /root ghcr.io/spwoodcock/awscli-kubectl:latest\naws sso login --profile admin --use-device-code\n\n# Install postgresql-client-16 (to match current pg version of pgstac)\napt install lsb-release wget gnupg\necho \\\n    \"deb https://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\" \\\n    &gt; /etc/apt/sources.list.d/pgdg.list\nwget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc \\\n    | apt-key add -\napt update\napt install postgresql-client-16\n\n# Port forward the db service\nkubectl port-forward service/eoapi-pgbouncer 5432:5432\n\n# Get the connection string\nkubectl get secrets eoapi-pguser-eoapi -o go-template='{{.data.uri | base64decode}}'\n# Replace eoapi-primary.eoapi.svc with localhost, as we are port-forwarding\nPGURL=&lt;output_from_plus_with_localhost&gt;\n\n# Dump the db in custom format\npg_dump -Fc \"$PGURL\" &gt; pgstac-backup.dump.gz\n</code></pre>"},{"location":"dev/backup-prod-pgstac/#restore","title":"Restore","text":"<p>See global-mosaic compose file for a <code>pg_restore</code> example.</p>"},{"location":"dev/frontend/","title":"OpenAerialMap","text":""},{"location":"dev/frontend/#vite-for-building","title":"Vite for building","text":"<p>Vite is used to bundle all the needed assets for the application. There are two commands, both run via <code>pnpm</code></p> <ul> <li><code>pnpm build</code> - clean &amp; build everything and put it into dist folder</li> <li><code>pnpm serve</code> - serve the pages and utilize live reload on changes to fonts, images, scripts and HTML.</li> </ul>"},{"location":"dev/frontend/#configurations-and-environment-variables","title":"Configurations and environment variables","text":"<p>This app makes use of the environment variables found in <code>../.env.example</code>. Copy and paste that file to a new file called <code>../.env</code> and populate the values.</p> <p>See Vite's documentation on env variables.</p>"},{"location":"dev/frontend/#aws-s3-for-deploy","title":"AWS S3 For Deploy","text":"<p>The deployment is:</p> <ul> <li>Handled via Justfile <code>deploy-frontend</code> script.</li> <li>The dist is pushed to S3 bucket <code>oam-frontend</code> under path <code>/${GIT_BRANCH}/</code>.<ul> <li>This way we host the main/stage/dev deployments in the same bucket,   under subpaths.</li> </ul> </li> <li>In advance a Cloudfront distribution is made in AWS, attached to   <code>*.hotosm.org</code> cert.</li> <li>The workflow will:<ul> <li>Build the frontend container image.</li> <li>Push the dist to S3.</li> <li>Find the Cloudfront distribution matching the S3 URL.</li> <li>Invalidate the cache of the cloudfront deployment in all locations.</li> </ul> </li> </ul>"},{"location":"dev/frontend/#linting","title":"Linting","text":"<p>Our ESLint rules are based on <code>eslint:recommended</code> rules, with some custom options. To check linting errors run:</p> <pre><code>npm run lint\n</code></pre>"},{"location":"dev/frontend/#tests","title":"Tests","text":"<p>Tests are setup using Jest, and can be run with</p> <pre><code>npm run test\n</code></pre>"},{"location":"dev/frontend/#coding-style","title":"Coding style","text":"<p>File .editorconfig defines basic code styling rules, like indent sizes.</p> <p>Prettier is the recommended code formatter. Atom and VSCode have extensions supporting Prettier-ESLint integration, which will help maintain style consistency while following linting rules.</p>"},{"location":"dev/frontend/#path-alias","title":"Path alias","text":"<p>Path alias allow you to define aliases for commonly used folders and avoid having very long file paths like <code>../../../component</code>. This also allows you to more easily move files around without worrying the imports will break.</p> <p>Paths are defined in the package.json under <code>alias</code>. They start with a <code>$</code> and point to a folder.</p> <p>The following paths are predefined, but feel free to change them to whatever is convenient to your project needs.</p> <pre><code>\"alias\": {\n    \"$components\": \"~/app/scripts/components\",\n    \"$styles\": \"~/app/scripts/styles\",\n    \"$utils\": \"~/app/scripts/utils\",\n    \"$test\": \"~/test\"\n  }\n</code></pre> <p>For example, to import a component from a file called <code>page-header</code> in the <code>\"~/app/scripts/components\"</code> folder, you'd just need to do <code>import Component from '$components/page-header'</code>.</p>"},{"location":"dev/frontend/#pull-request-templates","title":"Pull Request templates","text":"<p>Project seed comes with pull request templates to simplify and standardize the pull requests in the project. This issue on the how repo provides some context to how this works.</p> <p>To add more templates create them in the <code>.github/PULL_REQUEST_TEMPLATE</code> folder and link them in the PULL_REQUEST_TEMPLATE.md file.</p>"},{"location":"dev/new-provider/","title":"Adding a new data provider","text":"<p>This document walks through the process of adding a new data provider to the HOT OpenAerialMap (HOT OAM) STAC Catalog.</p>"},{"location":"dev/new-provider/#creating-stac-items","title":"Creating STAC items","text":"<p>The code to create STAC items for the OpenAerialMap STAC Catalog lives in stactools-hotosm. For an example of creating HOT OAM STAC item from existing Maxar items, see this file. Create a new branch, create a new directory for your provider, and write the code. Be sure to include tests. When it's ready, open a pull request (PR) with your changes.</p> <p>See the stactools-hotosm README for more.</p>"},{"location":"dev/new-provider/#add-ingestion","title":"Add ingestion","text":"<p>Create a PR on hotosm/k8s-infra to add a new manifest that syncs your data on a schedule. See sync-maxar for a representative example.</p>"},{"location":"dev/backend/global-mosaic/","title":"OpenAerialMap Global Mosaic","text":"<p>On a 24hr schedule:</p> <ul> <li>Generates global mosaic in PMTiles format, serving via S3.</li> <li>Also server TMS via a lightweight Martin server, for clients that   don't support PMTiles.</li> </ul>"},{"location":"dev/backend/global-mosaic/#getting-started","title":"Getting Started","text":"<p>This project uses uv to manage Python dependencies.</p> <p>Once <code>uv</code> is installed, you can install the dependencies by,</p> <pre><code>uv sync --all-groups\n</code></pre>"},{"location":"dev/backend/global-mosaic/#note-on-various-scripts","title":"Note On Various Scripts","text":"<p>The following <code>scripts</code> share a lot of code, and were developed iteratively:</p> <ul> <li>Attempt 1: <code>gen_mosaic_manual.py</code> - manually generate mosaics from COGs.</li> <li>Attempt 2: <code>gen_mosaic_hybrid.py</code> - hybrid coverage for zooms 0-10 + mosaic   for zooms 11-14 (from TiTiler instance). This is similar to the approach from   the original https://github.com/konturio/oam-mosaic-map, but uses our eoAPI   pgstac and TiTiler instead.</li> <li>Attempt 3: <code>gen_coverage_raster.py</code> - simple grey coverage pixels indicating   where we have imagery.</li> <li>Attempt 4: <code>gen_coverage_vector.py</code> - just use Tippecanoe for vector tiles \ud83e\udd26\u200d\u2642\ufe0f   All the approaches above need significant memory optimisation to run on   limited system resources / will require a bit more work. This approach   is much more efficient and simple.</li> </ul> <p>[!NOTE] For coverage tiles there are two approaches:</p> <ol> <li>Colour all pixels in the tile grey, meaning we massively reduce the    PMTiles size, due to internal tile deduplication.</li> <li>Partially colour pixels where appropriate, giving a more accurate    representation of coverage (more space, but looks nicer).    The gen_mosaic_raster.py script currently does approach 2.</li> </ol> <p>As of 2025-08-12 we are using <code>gen_coverage_vector.py</code> as the simplest approach, and is well optimised C++ code (low memory footprint). It generates tiles for zooms 0-15.</p>"},{"location":"dev/backend/global-mosaic/#note-on-s3-permissions","title":"Note On S3 Permissions","text":"<ul> <li>There is an IAM policy <code>oam-bucket-upload</code> with permission to upload   to the <code>oin-hotosm-temp</code> bucket.<ul> <li>We must ensure this policy also has <code>\"s3:PutObjectAcl\"</code> set, to allow   setting the global-mosaic.pmtiles file permission to public.</li> </ul> </li> <li>We have a user <code>hotosm-oam-global-mosaic-upload</code> that assigned this   IAM policy, plus access/secret key for uploading to the bucket.</li> </ul> <p>[!NOTE] There are no doubt better ways to do this from EKS, but using key/secret pairs for access is pretty simple and transferable amongst providers, rather than being AWS specific.</p>"},{"location":"dev/backend/global-mosaic/#development-testing","title":"Development Testing","text":"<ul> <li>See doc for loading prod pgSTAC into development</li> <li> <p>Add a <code>.env</code> to this directory, with content:</p> <pre><code>S3_ACCESS_KEY=KEY_FOR_OAM_BUCKET\nS3_SECRET_KEY=SECRET_FOR_OAM_BUCKET/zyalRchM+7\n</code></pre> </li> </ul> <ul> <li> <p>Run the script:</p> <pre><code>docker compose run --rm mosaicker\n</code></pre> </li> </ul>"},{"location":"dev/backend/stac-api/","title":"OpenAerialMap STAC API","text":"<p>This directory contains a customized version of the STAC FastAPI PgSTAC for OpenAerialMap. The only customization so far is to disable the \"transaction\" extension endpoints, but in the future this could enabled after adding in authorization logic to enable adding, updating, or deleting STAC records for certain users.</p>"},{"location":"dev/backend/stac-api/#getting-started","title":"Getting Started","text":"<p>This project uses uv to manage Python dependencies.</p> <p>Once <code>uv</code> is installed, you can install the dependencies by,</p> <pre><code>uv sync --all-groups\n</code></pre> <p>You can spin up the STAC FastAPI PgSTAC application using Docker Compose,</p> <pre><code>docker compose up app\n</code></pre> <p>Once the API is ready you can visit the OpenAPI documentation on your local machine by visiting, http://0.0.0.0:8082/api.html.</p>"},{"location":"dev/backend/stac-api/#upgrading","title":"Upgrading","text":"<p>The original source for <code>main.py</code> in this directory is: https://github.com/stac-utils/stac-fastapi-pgstac/blob/main/stac_fastapi/pgstac/app.py</p> <p>In order to upgrade, we should diff <code>main.py</code> against the 'official' <code>app.py</code> to check for changes to incorporate, then update the version pinned in <code>pyproject.toml</code>, relock, and redeploy.</p>"},{"location":"dev/backend/stac-ingester/","title":"OpenAerialMap STAC Ingester","text":"<p>This directory contains a deployment of the STAC ingester for HOTOSM based on the STAC creation package, stactools-hotosm.</p>"},{"location":"dev/backend/stac-ingester/#getting-started","title":"Getting Started","text":"<p>This project uses uv to manage Python dependencies.</p> <p>Once <code>uv</code> is installed, you can install the dependencies by,</p> <pre><code>uv sync --all-groups\n</code></pre>"}]}